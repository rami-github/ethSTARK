## Glossary

1. [Introduction](#1-Introduction)
2. [Disclaimers](#2-Disclaimers)
3. [Dockerfile Usage](#3-Dockerfile-Usage)
4. [Run Preliminaries](#4-Run-Preliminaries)
5. [Run Rescue Example](#5-Run-Rescue-Example)
6. [Prover Inputs](#6-Prover-Inputs)
7. [Run Ziggy Signature Example](#7-Run-Ziggy-Signature-Example)
8. [Running Tests](#8-Running-Tests)
9. [Measuring Security](#9-Measuring-Security)

------------------
## [1. Introduction](#Glossary)

STARKs (Scalable Transparent ARguments of Knowledge) are a family of proof systems characterized by
scalability and transparency. Scalability - via quasilinear proving time and poly-logarithmic
verification time, and transparency - meaning all verifier-side messages are public random coins
(requiring no trusted setup).

ZK-STARKs are STARKs that have the additional Zero-Knowledge property - informally meaning that the
verifier learns nothing about the prover's secret witness, except that it satisfies the proven
statement.

This project implements a ZK-STARK protocol as a non-interactive protocol between a prover and a
verifier. The prover sends a proof in order to convince the verifier that a certain statement is
true. Usually the proven statement indicates that a desired computation on some input was executed
correctly. The verifier reads the given proof in order to test the integrity of the proven
statement. To achieve this, the [BCS transformation](https://eprint.iacr.org/2016/116) is used to
transform a certain probabilistic proof into a non-interactive proof system; this transformation
combines Merkle trees and the Fiat-Shamir heuristic.

For an honest prover and a valid computation the verifier is guaranteed to accept the proof.
Otherwise, if the prover is dishonest or the computation is compromised, it would require an
infeasible amount of computation on the prover's part in order to produce a proof that the verifier
will not reject.

The Rescue-Hash statement proven by the prover given in this code is:

>"I know a sequence of n + 1 inputs {w_i} such that H(...H(H(w_0, w_1), w_2) ..., w_n) = p"

where:
- H is the Rescue hash function.
- Each w_i is a 4-tuple of field elements. These are private inputs, known only to the prover.
- p is the public output of the hash (which also consists of 4 field elements).

For more details, see our [external documentation](https://docs.google.com/viewer?url=https://github.com/starkware-libs/ethSTARK/raw/master/rescue_stark_documentation.pdf).

### [1.1 Ziggy](#Glossary)

This project also includes a Post-Quantum-Secure signature scheme based on a ZK-STARK,
called **Ziggy**. The construction is as follows:

**Ziggy Key Generation**

- Private Key: a sequence sk of 32 bytes.
- Secret Preimage: an 8-tuple of field elements w that is deterministically generated from sk.
- Public Key: pk = H(w), the result of applying the Rescue hash function on the secret preimage.

**Ziggy Signing Algorithm**

To sign on the message m, using the pair of keys sk and pk, use a ZK-STARK prover to generate a
non-interactive zero-knowledge proof &pi; for the statement:

>"I know a secret preimage w such that pk = H(w)"

The proof is generated using the message m and the public key pk as the source of public random
coins. To make the proof both zero-knowledge and deterministic, The private key sk and the message m
are used as the source of secret random coins.

**Ziggy Signature Verification**

Given a message m, a public key pk and a proof &pi;, use the ZK-STARK verifier to check the
integrity of &pi; as a ZK-STARK proof, using m and pk as the source of public random coins. If the
verifier accepts the proof &pi;, then it is convinced that &pi; has been generated by the owner of
the private key and that the signer intentionally used the message m in that process.

The following sections explain how to compile and run the tests and benchmarks in this project, as
well as explaining the meaning and usage of the prover inputs.

-----------------
## [2. Disclaimers](#Glossary)

1. The code presented in this project has been audited by
[PeckShield Inc.](https://peckshield.com/en), their
[report](https://starkware.co/peckshield_ethstark_audit/) refers to commit
[98c3df5](https://github.com/starkware-libs/ethSTARK/commit/98c3df50e124bd00124315a693bb0fae76331eb3).
The main differences from the audited commit are:
- This version is configured for 128 bits of security instead of 80.
- In this version it is possible to enable zero-knowledge.
- This version includes a ZK-STARK based signature scheme, called Ziggy.

2. The system is designed to guarantee up to 128 bits of security, depending on hardcoded values and
on several parameters given as input. Refer to the [[Measuring Security](#9-Measuring-Security)]
section for more details.

3. The chain-length (representing the number of Rescue hash invocations) must be divisible by 3.
This is done for simplicity, since batches of 3 hashes are fit into 32 rows in the Rescue hash
trace.

4. This project only supports compilation on a Linux (Ubuntu 18.04) environment. For other operating
systems, a Dockerfile is included in order to simulate such an environment (Refer to the
[[Dockerfile Usage](#3-Dockerfile-Usage)] section).

----------------------
## [3. Dockerfile Usage](#Glossary)

For operating systems which are not compatible with this project, the source directory holds a
dedicated Dockerfile, which automatically runs the unit tests and end-to-end tests on a simulated
Ubuntu 18.04 environment.

To use this, simply navigate to the cloned source directory and run:

```bash
> docker build --tag ethstark .
```

Once the docker image is built, a terminal may be accessed in the simulated Ubuntu environment
using:

```bash
> docker run -it ethstark
```

From there the project's code can be compiled and run as detailed in the following sections.

-----------------
## [4. Run Preliminaries](#Glossary)

In order to run the examples, first make sure to install dependencies, this can be done by running
the following script:

```bash
> ./install_deps.sh
```

Next, compile the project code by running the following commands into the terminal (from the
project's source directory):

```bash
> mkdir -p build/Release
> cd build/Release
> cmake ../.. -DCMAKE_BUILD_TYPE=Release
> make -j
> cd ../..
```

-----------------
## [5. Run Rescue Example](#Glossary)

The prover requires a private input file (representing the witness for the proven statement). In
order to randomize the prover's private input used by this example code, use:

```bash
> PYTHONPATH=src examples/rescue/random_private_input.py --chain_length=3
```

>**NOTE: Other chain length values will require appropriate changes to the
`examples/rescue/rescue_params.json` file (see [[Prover Inputs](#6-Prover-Inputs)] section).**

Once the code is compiled, the dependencies installed, and the random private input is generated,
use the following command to run the STARK prover:

```bash
> build/Release/src/starkware/main/rescue/rescue_prover \
    --parameter_file examples/rescue/rescue_params.json \
    --prover_config_file examples/rescue/rescue_prover_config.json \
    --public_input_file examples/rescue/rescue_public_input.json \
    --private_input_file examples/rescue/rescue_private_input.json \
    --out_file examples/rescue/proof.json \
    --logtostderr
```

The flags used in the above command define paths to example files containing the various prover
inputs. For a more detailed description of these inputs, refer to the
[[Prover Inputs](#6-Prover-Inputs)] section of this guide.

Finally, run the STARK verifier using:

```bash
> build/Release/src/starkware/main/rescue/rescue_verifier \
    --in_file examples/rescue/proof.json \
    --logtostderr
```

The file `examples/rescue/proof.json` is generated after running the prover as described above, and contains
the proof along with the public input, given to the verifier for verification.

If all goes well the end result should be a successful validation of the proof by the verifier.

-------------------
## [6. Prover Inputs](#Glossary)

### Parameter file
Contains parameters that configure the STARK protocol. This affects the way the proof is generated
by the prover and interpreted by the verifier.

>**NOTE: Some of the values in this file affect the security level of the system. Consult the
[[Measuring Security](#9-Measuring-Security)] section for more details.**

```json
{
    "stark": {
        "fri": {
            "fri_step_list": [
                0,
                1,
                3,
                3
            ],
            "last_layer_degree_bound": 1,
            "n_queries": 56,
            "proof_of_work_bits": 18
        },
        "log_n_cosets": 2,
        "enable_zero_knowledge": true
    }
}
```

>**NOTE: The values given in "fri_step_list" and "last_layer_degree_bound" should satisfy: \
_sum(fri_step_list) + log2(last_layer_degree_bound) = log2(trace_length)_ \
where trace_length is equal to 32 * chain_length / 3, rounded up to the nearest power of 2.**

>**NOTE: If enable_zero_knowledge is true then the first value in "fri_step_list" has to be 0,
meaning that the prover commits on the first FRI layer (otherwise the verifier computes it himself
from the oracle to the committed trace).**

### Prover config file
Contains a configuration governing the way the prover operates internally in order to tweak
performance. This has no affect on the produced proof or the way the verifier reads it.

```json
{
    "constraint_polynomial_task_size": 256
}
```

### Public input file
Contains the public input, which represents data known to both the prover and the verifier. In the
case of the Rescue hash statement, the public input is the output of the Rescue hash function, for
which the prover claims to know the inputs which produce it (In the Rescue hash statement in the
[[Introduction](#1-Introduction)] section this is represented by `p`). Furthermore, `chain_length`
represents the number of Rescue hash invocations in the proven statement (represented by `n` in the
statement).

```json
{
    "output": [
        "0xb87ffc3341ef328",
        "0x1825dd4dfceaa726",
        "0x1e869731f5a4318",
        "0x1239e1d4648b2716"
    ],
    "chain_length": 3
}
```

### Private input file
Contains private data known only by the prover, and used to generate the proof. In the case of the
Rescue hash statement, the private input is a series of inputs whose hash (as defined above) is
given in the public input file, and representing the points {w_i} whose combined hash results in the
desired output.

```json
{
    "witness": [
        [
            "0x12e4f2bfa4bedb74",
            "0x1bbb965e8fd3d6e",
            "0x4992d0f548d72d2",
            "0x1704eaf08d47dab5"
        ],
        [
            "0x3f3eeb71ad8960e",
            "0x172a32b0942db2b7",
            "0xf7cefd948bf82b6",
            "0x1e096a30ec5a1c8"
        ],
        [
            "0x65f0bf6258e54e",
            "0x1c1f0fcd9420f4b8",
            "0xa7213eb3fe40af3",
            "0x15e178d3990c036"
        ],
        [
            "0x3eae9a8c9777c40",
            "0x1b09401086b5282b",
            "0xdeee4f5fa8573e2",
            "0x36f3a7c772e42f"
        ]
    ]
}
```

-----------------
## [7. Run Ziggy Signature Example](#Glossary)

In order to generate the private and public input files (which contain the keys and the message)
use:

```bash
> PYTHONPATH=src examples/ziggy/generate_keys.py --private_key=[private_key] --message=[message]
```

Where \[private_key\] is a hexadecimal number with up to 64 hex digits and \[message\] is a string.

>**NOTE: The private key and message parameters are optional. If a parameter is omitted it will be
replaced by a random/default value.**

Once the code is compiled, the dependencies installed, and the keys are generated, use the following
command to sign the message:

```bash
> build/Release/src/starkware/main/ziggy/ziggy_prover \
    --parameter_file examples/ziggy/ziggy_params.json \
    --prover_config_file examples/ziggy/ziggy_prover_config.json \
    --public_input_file examples/ziggy/ziggy_public_input.json \
    --private_input_file examples/ziggy/ziggy_private_input.json \
    --out_file examples/ziggy/proof.json \
    --logtostderr
```

The inputs for the signing algorithm are similar to Rescue hash chain prover inputs described in the
[[Prover Inputs](#6-Prover-Inputs)] section of this guide. The differences are as the
public_input_file and private_input_file, which depend on the proven statement.

```json
{
    "message": "Hello World!",
    "public_key": [
        "0x55f6e86209435ae",
        "0xea6a220143cf04b",
        "0x9e566996b19788b",
        "0x1f5d2514e876b9da"
    ]
}
```

```json
{
    "private_key": "0x32a4cc574f9ae3a67f1eac604dbc9822042856b8184557da016affbc3008a688"
}
```

Finally, run the ziggy verifier using:

```bash
> build/Release/src/starkware/main/ziggy/ziggy_verifier \
    --in_file examples/ziggy/proof.json \
    --logtostderr
```

The file `examples/ziggy/proof.json` is generated after running the prover as described above,
and contains the Ziggy signature along with the public input, given to the verifier for
verification.

If all goes well the end result should be a successful validation of the Ziggy signature by the
verifier.

---------------------------------------------
## [8. Running Tests](#Glossary)

Refer to the [[Run Preliminaries](#4-Run-Preliminaries)] section for the commands to build the
project code.

To run all the unit tests available in this project, use:

```bash
> (cd build/Release; ctest -v)
> pytest
```

The project has four benchmarks, one for the prover and one for the verifier of each of the two
implemented statements. They can be executed
using:

```bash
> build/Release/src/starkware/benchmarks/rescue_prover_benchmark
> build/Release/src/starkware/benchmarks/rescue_verifier_benchmark
> build/Release/src/starkware/benchmarks/ziggy_prover_benchmark
> build/Release/src/starkware/benchmarks/ziggy_verifier_benchmark
```

------------------------
## [9. Measuring Security](#Glossary)

As mentioned in the [[Disclaimers](#2-Disclaimers)] section, this system is designed to support up
to 128-bits of security. By security we mean the hardness of generating a false proof that is
accepted by the verifier even though the prover doesn't know a valid witness (or even though such
witness does not exist). Note that this is independent of the zero-knowledge security, which
controls the probability of learning any non-trivial information about the prover's secret witness
(and thus the secret signing key).

The security of this system is the minimum of three values:

1. log_n_cosets * n_queries + proof_of_work_bits (these are the parameters that appear in the
parameter_file. Refer to the [[Prover Inputs](#6-Prover-Inputs)] section for details).
2. The collision resistance of the hash used by the protocol. This system employs Blake2s256 for the
protocol, which is considered to provide 128 bits of security at the time of writing this project.
3. log(extension_field_size) - log(trace_length) (where the extension field is hardcoded to be of
size 183 bits, and trace_length = (chain_length / 3) * 32 rounded up to nearest power of 2).

In the information-theoretic IOP model, the ethSTARK IOP yields 128 bits of **provable soundness**
(a stronger notion than "security") when using it with the following parameters:
1. n_queries = 92
2. proof_of_work_bits = 18
3. log_n_cosets = 4
4. log(trace_length) &le; 20 (which is the case for chain_length up to 98304)

For more information regarding the proven security bound on the soundness of the FRI protocol (used
as the LDT component of the STARK protocol), refer to section [7.2] in this paper:
[https://eprint.iacr.org/2020/654](https://eprint.iacr.org/2020/654).
