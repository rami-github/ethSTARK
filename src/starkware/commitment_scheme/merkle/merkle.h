#ifndef STARKWARE_COMMITMENT_SCHEME_MERKLE_MERKLE_H_
#define STARKWARE_COMMITMENT_SCHEME_MERKLE_MERKLE_H_

#include <array>
#include <cassert>
#include <cstring>
#include <map>
#include <memory>
#include <set>
#include <utility>
#include <vector>

#include "glog/logging.h"
#include "third_party/gsl/gsl-lite.hpp"

#include "starkware/channel/prover_channel.h"
#include "starkware/channel/verifier_channel.h"

namespace starkware {

/*
  Merkle Tree.
*/
class MerkleTree {
 public:
  explicit MerkleTree(uint64_t data_length) : data_length_(data_length), nodes_(2 * data_length) {
    ASSERT_RELEASE(IsPowerOfTwo(data_length), "Data length is not a power of 2.");
    VLOG(3) << "Constructing a Merkle tree for data length = " << data_length;
    // We use an array that has one extra cell we never use at the beginning, to make indexing
    // nicer.
  }

  /*
    Adds data to the tree. The start_index argument is used so that data may be fed
    into the tree in any order, and by different threads.
    start_index + data.size() has to be smaller than the data length declared at construction.
  */
  void AddData(gsl::span<const Blake2s256> data, uint64_t start_index);

  /*
    Retrieves the root of the tree.
    This entails computing the inner-nodes' hashes, however, some of the inner nodes' hashes may
    already be known, in which case it will be more efficient to start the computation at the
    minimal depth (depth = distance from the root) where at least one node is unknown. The minimal
    depth assumed to be completely correct is specified by min_depth_assumed_correct argument.

    For example, in a tree with 16 leaves, if the immediate parents of all the leaves were already
    computed because they were entered in pairs, using AddData(), the most efficient way to
    compute the root will be calling GetRoot(3). This is because depth 4 nodes are simply the leaves
    - which were explicitly fed into the tree, and we assume depth-3 nodes were computed implicitly,
    since the leaves were fed in pairs. Similarly, calling GetRoot(0) causes no hash operations to
    be performed, and simply returns the root stored from the last time it was computed.
  */
  Blake2s256 GetRoot(size_t min_depth_assumed_correct);

  /*
    Generates and sends to the channel minimal consistency proof between the Merkle tree root
    and the values in the queried indices.
    The proof does not include the values of those indices, nor the Merkle root.
  */
  void GenerateDecommitment(const std::set<uint64_t>& queries, ProverChannel* channel) const;

  /*
    Given a Merkle root, and claimed values of a subset of its leaves (data_to_verify),
    reads and verifies a proof of consistency from the channel (generated by an invocation of
    GenerateDecommitment()). 'total_data_length' is the total number of leaves in the Merkle tree.
  */
  static bool VerifyDecommitment(
      const std::map<uint64_t, Blake2s256>& data_to_verify, uint64_t total_data_length,
      const Blake2s256& merkle_root, VerifierChannel* channel);

  uint64_t GetDataLength() const;

 private:
  const uint64_t data_length_;
  std::vector<Blake2s256> nodes_;

  void SendDecommitmentNode(uint64_t node_index, ProverChannel* channel) const;
};

}  // namespace starkware

#endif  // STARKWARE_COMMITMENT_SCHEME_MERKLE_MERKLE_H_
