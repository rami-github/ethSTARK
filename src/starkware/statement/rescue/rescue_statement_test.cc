#include "starkware/statement/rescue/rescue_statement.h"

#include "gtest/gtest.h"

#include "starkware/air/air.h"
#include "starkware/algebra/fields/base_field_element.h"
#include "starkware/error_handling/test_utils.h"

namespace starkware {
namespace {

/*
  Tests that the code compiles and doesn't throw any runtime exceptions.
*/
TEST(RescueStatement, BasicTest) {
  auto public_input = JsonValue::FromString(R"(
  {
      "chain_length": 3,
      "output": [
        "0x68956e24301f0d6",
        "0x1db6f48d1e36f2b4",
        "0x15ba54b9652e4c33",
        "0x199d7c05484a2ff8"
      ]
  }
  )");
  auto private_input = JsonValue::FromString(R"(
  {
      "witness": [
        ["0x1","0x2","0x3","0x4"], ["0x5","0x6","0x7","0x8"],
        ["0x1","0x2","0x3","0x4"], ["0x5","0x6","0x7","0x8"]
      ]
  }
  )");
  RescueStatement statement(public_input, private_input);
  EXPECT_ASSERT(
      statement.GetTrace(nullptr),
      testing::HasSubstr("Cannot construct trace without a fully initialized AIR instance."));
  // Check the type of the returned AIR.
  EXPECT_NE(dynamic_cast<const RescueAir*>(&statement.GetAir(false, 0)), nullptr);

  // Test GetInitialHashChainSeed by comparing the result to a precalculated value. The seed is
  // generated by serializing the string "Rescue hash chain" (including a terminating null
  // character: 0x52, 0x65, ..., 0x6e, 0x00) and the public input to a vector of bytes. First
  // the output, and then the chain_length. Note that you will not be able to spot the output
  // elements because they are in Montgomery form. However, the chain length is easy to spot. The
  // following also tests that the public_input was parsed correctly by RescueStatement constructor.
  std::vector<unsigned char> claimed_seed{
      0x52, 0x65, 0x73, 0x63, 0x75, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x63, 0x68, 0x61,
      0x69, 0x6e, 0x00, 0x10, 0x6d, 0x8d, 0x1e, 0x96, 0xa2, 0xd0, 0x34, 0x07, 0x70, 0x8a, 0xe7,
      0xa1, 0x0e, 0xcf, 0x23, 0x1e, 0x50, 0xd8, 0xc9, 0x7a, 0x34, 0xf9, 0x82, 0x09, 0x21, 0xf5,
      0x25, 0xd1, 0x1a, 0x4a, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03};

  ASSERT_EQ(
      gsl::make_span(statement.GetInitialHashChainSeed()),
      gsl::make_span(claimed_seed).as_span<std::byte>());

  statement.GetTrace(nullptr);
}

/*
  Tests FixPublicInput accurately fixes the public input to the right public input.
*/
TEST(RescueStatement, FixPublicInput) {
  auto private_input = JsonValue::FromString(R"(
  {
      "witness": [
        ["0x1","0x2","0x3","0x4"], ["0x5","0x6","0x7","0x8"],
        ["0x1","0x2","0x3","0x4"], ["0x5","0x6","0x7","0x8"]
      ]
  }
  )");
  auto real_public_input = JsonValue::FromString(R"(
  {
      "chain_length": 3,
      "output": [
        "0x68956e24301f0d6",
        "0x1db6f48d1e36f2b4",
        "0x15ba54b9652e4c33",
        "0x199d7c05484a2ff8"
      ]
  }
  )");
  auto fake_public_input = JsonValue::FromString(R"(
  {
      "chain_length": 3,
      "output": [
        "0x1",
        "0x1",
        "0x1",
        "0x1"
      ]
  }
  )");

  RescueStatement statement(fake_public_input, private_input);
  auto public_input = statement.FixPublicInput();
  ASSERT_EQ(public_input.ToJsonString(), real_public_input.ToJsonString());
}

}  // namespace
}  // namespace starkware
