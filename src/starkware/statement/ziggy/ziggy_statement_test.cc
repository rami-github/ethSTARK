#include "starkware/statement/ziggy/ziggy_statement.h"

#include "gtest/gtest.h"

#include "starkware/air/air.h"
#include "starkware/algebra/fields/base_field_element.h"
#include "starkware/error_handling/test_utils.h"

namespace starkware {
namespace {

/*
  Tests that the code compiles and doesn't throw any runtime exceptions.
*/
TEST(ZiggyStatement, BasicTest) {
  Prng prng;
  auto public_input = JsonValue::FromString(R"(
  {
      "message": "Hello World!",
      "public_key": [
        "0x9fe62e51380bdfc",
        "0x176df573b3bf5d69",
        "0xdac18e0d0724b33",
        "0x1dbba6f8ff63183a"
      ]
  }
  )");
  auto private_input = JsonValue::FromString(R"(
  {
      "private_key": "0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
  }
  )");
  ZiggyStatement statement(public_input, private_input);
  EXPECT_ASSERT(
      statement.GetTrace(&prng),
      testing::HasSubstr("Cannot construct trace without a fully initialized AIR instance."));
  // Check the type of the returned AIR.
  EXPECT_NE(dynamic_cast<const ZiggyAir*>(&statement.GetAir(true, 1)), nullptr);

  // Test GetInitialHashChainSeed by comparing the result to a precalculated value. The seed is
  // generated by serializing the string "Ziggy" (including a terminating null character), the
  // public key and the message to a vector of bytes. Note that you will not be able to spot the
  // public key elements because they are in Montgomery form. The following also tests that the
  // public_input was parsed correctly by ZiggyStatement constructor.
  std::vector<unsigned char> claimed_seed{
      0x5a, 0x69, 0x67, 0x67, 0x79, 0x0,  0x1e, 0x35, 0x36, 0xd1, 0x5b, 0xe8, 0x6a,
      0x4a, 0x0,  0xd1, 0x6d, 0x8b, 0x87, 0xd0, 0xe,  0x9,  0x4,  0xe4, 0xb4, 0x8d,
      0xd8, 0xe9, 0xdf, 0xc4, 0x1,  0x65, 0xa6, 0x94, 0xaf, 0x29, 0xbe, 0x4a, 0x48,
      0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,
  };

  ASSERT_EQ(
      gsl::make_span(statement.GetInitialHashChainSeed()),
      gsl::make_span(claimed_seed).as_span<std::byte>());

  // Test GetZeroKnowledgeHashChainSeed by comparing the result to a precalculated value. The seed
  // is generated by serializing the string "Ziggy private seed" (including a terminating null
  // character) and the private key to a vector of bytes. The following also tests that the
  // private_input was parsed correctly by ZiggyStatement constructor.
  std::vector<unsigned char> claimed_private_seed{
      0x5a, 0x69, 0x67, 0x67, 0x79, 0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65,
      0x20, 0x73, 0x65, 0x65, 0x64, 0x0,  0x0,  0x1,  0x2,  0x3,  0x4,  0x5,  0x6,
      0x7,  0x8,  0x9,  0xa,  0xb,  0xc,  0xd,  0xe,  0xf,  0x10, 0x11, 0x12, 0x13,
      0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x48,
      0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,
  };

  ASSERT_EQ(
      gsl::make_span(statement.GetZeroKnowledgeHashChainSeed()),
      gsl::make_span(claimed_private_seed).as_span<std::byte>());

  statement.GetTrace(&prng);
}

/*
  Test that FixPublicInput produces the correct public input.
*/
TEST(ZiggyStatement, FixPublicInput) {
  auto private_input = JsonValue::FromString(R"(
  {
      "private_key": "0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
  }
  )");
  auto expected_public_input = JsonValue::FromString(R"(
  {
      "message": "Hello World!",
      "public_key": [
         "0x9fe62e51380bdfc",
        "0x176df573b3bf5d69",
        "0xdac18e0d0724b33",
        "0x1dbba6f8ff63183a"
      ]
  }
  )");
  auto fake_public_input = JsonValue::FromString(R"(
  {
      "message": "Hello World!",
      "public_key": [
        "0x1",
        "0x1",
        "0x1",
        "0x1"
      ]
  }
  )");

  ZiggyStatement statement(fake_public_input, private_input);
  auto public_input = statement.FixPublicInput();
  ASSERT_EQ(public_input.ToJsonString(), expected_public_input.ToJsonString());
}

}  // namespace
}  // namespace starkware
